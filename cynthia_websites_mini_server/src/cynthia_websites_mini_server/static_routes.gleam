import bungibindies/bun/http/serve/response
import bungibindies/bun/spawn.{OptionsToSubprocess}
import cynthia_websites_mini_client
import cynthia_websites_mini_client/configtype
import cynthia_websites_mini_client/ui
import cynthia_websites_mini_server/mutable_model_type
import cynthia_websites_mini_server/utils/files.{client_css, client_js}
import gleam/bool
import gleam/dict
import gleam/javascript/array
import gleam/list
import gleam/option.{type Option, None, Some}
import gleam/result
import gleam/string
import gleamy_lights/console
import javascript/mutable_reference

import plinth/node/process
import simplifile

pub fn static_routes(mutable_model: mutable_model_type.MutableModel) {
  let model = mutable_model |> mutable_reference.get()
  dict.new()
  |> dict.insert("/index.html", main(model.config))
  |> dict.insert("/404", notfound())
  |> Some
}

pub fn index_html(gc: configtype.SharedCynthiaConfigGlobalOnly) {
  "<!DOCTYPE html>
<html lang='en'>
<!--
  This site is hosted and generated by Cynthia Mini " <> cynthia_websites_mini_client.version() <> ", a mostly-static site generator written in Gleam.

  Also see: <https://github.com/CynthiaWebsiteEngine/Mini>
-->

<head>
<title>&lt;&lt;site hosted by Cynthia mini&gt;&gt;</title>
<meta property='og:site_name' content='" <> gc.global_site_name <> "'/>
<meta property='og:description' content='" <> gc.global_site_description <> "'/>
<meta name='theme-color' content='" <> gc.global_colour <> "' />
<link rel='shortcut icon' href='./assets/site_icon.png' type='image/x-icon'/>
<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<script type='module'>
  // Cynthia Mini Client JS, minified by Bun.\n\n\n
" <> client_js() <> "
</script>
<style>" <> client_css() <> "</style>
</head>
<body>
  <div id='viewable' class='bg-base-100 w-screen h-screen'>
  </div>
 " <> footer(True, gc.git_integration) <> "
</body>
</html>
"
}

fn main(gc: configtype.SharedCynthiaConfigGlobalOnly) {
  response.new()
  |> response.set_body(index_html(gc))
  |> response.set_headers(
    [#("Content-Type", "text/html; charset=utf-8")]
    |> array.from_list(),
  )
  |> response.set_status(200)
}

fn notfound() {
  response.new()
  |> response.set_body("<!DOCTYPE html>
  <html lang='en'>
  <head>
  <title>cynthia_websites_mini_server</title>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <script type='module'>
  " <> client_js() <> "
  </script>
  <style>" <> client_css() <> "</style>
  </head>
  <body data-404='true' class='bg-base-100 w-[100VW] h-[100VH]'>
    " <> ui.notfoundbody() <> "
    </body>
      </html>
")
  |> response.set_headers(
    [#("Content-Type", "text/html; charset=utf-8")]
    |> array.from_list(),
  )
  |> response.set_status(404)
}

pub fn footer(can_hide: Bool, git_integration: Bool) {
  let f = case git_integration {
    True ->
      [ui.footer]
      |> list.append(
        case { simplifile.is_directory(process.cwd() <> "/.git/") } {
          Ok(True) -> {
            console.log("[Git integration] git repository detected")
            [
              ", created from "
              <> case
                helper_get_git_remote_commit(),
                {
                  spawn.sync(OptionsToSubprocess(
                    cmd: ["git", "rev-parse", "--short", "HEAD"],
                    cwd: Some(process.cwd()),
                    env: None,
                    stderr: Some(spawn.Ignore),
                    stdout: Some(spawn.Pipe),
                  ))
                  |> spawn.stdout()
                  |> result.map(string.trim)
                  |> result.map(string.to_option)
                }
              {
                Some(commit_url), Ok(Some(commit_id)) ->
                  "commit <a href=\""
                  <> commit_url
                  <> "\" class=\"dark:text-sky-600 text-sky-800 underline\"><code>"
                  <> commit_id
                  <> "</code></a>."
                None, Ok(Some(commit_id)) ->
                  " commit id <code>" <> commit_id <> "</code>."
                _, _ -> "a git repo."
              },
            ]
          }
          _ -> {
            []
          }
        },
      )
      |> string.concat
    False -> {
      console.log("[Git integration] git repository not detected")
      ui.footer
    }
  }
  "<footer id='cynthiafooter' class='footer transition-all duration-[2s] ease-in-out footer-center bg-base-300 dark:bg-slate-800 text-base-content dark:text-base-200 p-1 h-fit fixed bottom-0 max-h-1/8'><aside><p>"
  <> f
  <> "</p></aside></footer>"
  <> case can_hide {
    True ->
      "
    <script defer>
	window.setTimeout(function () {
		window.addEventListener('scroll',
			function () {
				const classname = 'max-h-[5px]';
				document.querySelector('#cynthiafooter').style.height = '5px';
				document.querySelector('#cynthiafooter').addEventListener('click', function () {
					document.querySelector('#cynthiafooter').style.height = '';
				});
			},
			true,
		);
	}, 4000);
       </script>"
    False -> ""
  }
}

/// If succeeds, returns a html link to the current commit on the remote, by just removing the last part of the URL and adding "/commit/<commit_hash>".
fn helper_get_git_remote_commit() -> Option(String) {
  let remote_cmd =
    spawn.sync(OptionsToSubprocess(
      cmd: ["git", "config", "--get", "remote.origin.url"],
      cwd: Some(process.cwd()),
      env: None,
      stderr: Some(spawn.Ignore),
      stdout: Some(spawn.Pipe),
    ))
    |> spawn.stdout()
    |> result.map(string.trim)
    |> option.from_result()
    |> option.map(fn(str) {
      case string.ends_with(str, ".git") {
        True -> string.drop_end(str, 4)
        False -> str
      }
    })
  use remote <- option.then(remote_cmd)
  // If remote does not start with http(s), we can't use it.
  use <- bool.guard(
    when: bool.negate(string.starts_with(remote, "http")),
    return: None,
  )
  let commit_cmd =
    spawn.sync(OptionsToSubprocess(
      cmd: ["git", "rev-parse", "--verify", "HEAD"],
      cwd: Some(process.cwd()),
      env: None,
      stderr: Some(spawn.Ignore),
      stdout: Some(spawn.Pipe),
    ))
    |> spawn.stdout()
    |> result.map(string.trim)
    |> option.from_result()
  use commit <- option.then(commit_cmd)
  Some(remote <> "/commit/" <> commit)
}
